---
title: "Main Program for Final Project"
author: "Rebecca Thomson"
date: "2024-07-16"
output: html_document
---
This is the main program for analyzing District Maps.  
'Input_Analysis.Rmd' will analyze and check input data.

```{r setup, echo=FALSE}
knitr::opts_chunk$set(echo = TRUE)
#Packages to install,commented out is default.

#install.packages("dplyr")
#install.packages("gglot2")
#install.packages("redist")
#install.packages("Rtools")
#install.packages("alarmdata")
#install.packages('ggredist')

```

## Libraries

These are all the libraries used for the project.  We have tried to comment which part they were first called for use.

```{r Libraries}
library(tidyverse)
#library(Rtools)
library(redist) #Map Analysis
library(dplyr)
library(ggplot2)
library(alarmdata) #State graph/mapping data
library(ggredist) #Alarm data mapping
library(rlist)
```

## Global Provided Information and Constraints
The global information and constraints are not changed during any algorithm or analysis, except addition of proposed Congressional Districts when the creation algorithm is completed.
This information will be modified for each state analyzed.

These are the variables that are global: 
-Loading initial state information (selecting which state to analyze)
-The list of Final District node choices.  It is a list of lists of what nodes are in created districts, it shall be modified by our analysis and starts out empty.

These are the constraints that are global:
-Required number of Districts
-The range of population values allowed in each district.  Historically, this is plus or minus 1% of the Total Population/Number of Districts.


```{r Base Global Information}
#Selecting state and entering base information
#This_State<-read.csv(file='ks_2020_vtd.txt')
This_state_map<-alarm_50state_map('KS')

#Code in number of Districts
number_districts<- 2 #Hard-coded number of Congressional Districts, the minimum is two.

#Create Empty list of future districts- final_district
final_district<-vector(mode="list",number_districts)

#Total Population
tot_pop<-sum(This_state_map$pop)

Population_Range<-c((tot_pop/number_districts)-0.01*(tot_pop/number_districts), (tot_pop/number_districts)+0.01*(tot_pop/number_districts) )

```

## Create list of Nodes Function

This function produces an original list of all nodes.  It is a list of lists, where each list is: 
[
[(original node index(integer)],                 
[raw population number of node(integer)],
[list of adjacent nodes by original index number[],[],[]....],
[0 (for later tracking in other functions, integer)]
]

The purpose of this function is to:
-Protect the original data from loss or corruption.
-Isolate each node into its own list for ease of analysis.  This will make creating lists of nodes within districts and lists of adjacent nodes easier.
```{r All Nodes Original List}
create_node_list<-function(){
all_nodes_adjlist<- This_state_map$adj
all_nodes_poplist<-This_state_map$pop
all_nodes_index<-1:(length(This_state_map$pop))
all_nodes_all_list<-list()
for (i in 1:(length(all_nodes_poplist))){
  temp_list<-list()
  temp_list[[length(temp_list)+1]]<-all_nodes_index[[i]]
  temp_list[[length(temp_list)+1]]<-all_nodes_poplist[i]
  temp_list[[length(temp_list)+1]]<-all_nodes_adjlist[[i]]
  
  temp_list[length(temp_list)+1]<-c(0)
  
  all_nodes_all_list[[length(all_nodes_all_list)+1]]<-temp_list

}
return (all_nodes_all_list)
}

```
## Created Global Information

```{r create Global}
#Iterate-able list of all nodes.
GLOBALNODESLIST<-create_node_list()

#Original Nodes - DO NOT MODIFY!
Unmodified_Global_Nodes_List<-create_node_list()


```

## R function to Remove a node from the Adjacency list
This function takes the node to be removed from the adj.list.  The function should be used when a node is added to the district being built. 
The function removes the node from the adjacency list, removes any mention of the node in other nodes' lists, and increases the count of adjacencies within those node's adjacency lists- because now the district has one more adjacency.

```{r function to remove node }

node.to.remove<-function(remove.this.node){
  
  #First, the node must be removed from other node's adjacency lists.  We do not need to keep track of which nodes are adjacent to our district sub-graph, because all nodes in the adjacency list are connected to the district.
  #Second, while we are removing the node from the exterior node's adjacency lists, we need to update the Number of Connections each exterior and adjacent node has to the district sub-graph.
  for (i in (length(adj.list)):1){
    for (j in (length(adj.list[[i]][[3]])):1){
      if ((as.numeric(adj.list[[i]][[3]][j]))==as.numeric(remove.this.node)){
        adj.list[[i]][[3]][j]<- NA #
        adj.list[[i]][[4]][[1]]<-1+as.numeric(adj.list[[i]][[4]][[1]])
      
      }
    }
  }
  #Lastly, remove this node from the adjacency list.  It is only listed once, so it will not cause problems with our iteration.
  for (i in (length(adj.list)):1){
    if((as.numeric(adj.list[[i]][[1]]))==as.numeric(remove.this.node)){
      
      adj.list[[i]]<-NA
      #list.remove(adj.list, c(i))
    }
  }
  
}
```
## R function to add a single node to Adjacency List
GLOBALNODELIST is the Global-level list that is a modifiable list of all the nodes that have not yet been used to build districts.  It shall be modified with a different function. However, the indexing is the same as the node name at all times- any modification is just setting the node name to 'na' so that we can continue to use the list without excessive lookup times.

This function shall copy the node from the exterior node list and place it in the adjacency list.  It shall return nothing, since adj.list is a global variable that is set to zero when each new district is created.

```{r function to add node}
add.node<-function(new.adj.node){
  #building individual node list to bring into adjacency list
  temp1<-list()
  temp1[[length(temp1)+1]]<-(as.numeric(GLOBALNODESLIST[[new.adj.node]][[1]]))
      
  temp1[[length(temp1)+1]]<-(as.numeric(GLOBALNODESLIST[[new.adj.node]][[2]]))
  temp1[[length(temp1)+1]]<-GLOBALNODESLIST[[new.adj.node]][[3]]
  #Remember that these nodes are now connected to the district list, and should start with +1 adjacency.
  temp1[[length(temp1)+1]]<-(as.numeric(GLOBALNODESLIST[[new.adj.node]][[4]])+1)
      
  adj.list[[(length(adj.list)+1)]]<-temp1 #Add node to adjacency
  #And remove the name of node from the exterior list
  exterior.node.removal(new.adj.node)
      }

```

#Function to remove node from possible exterior nodes list.
When a node is selected, run this code to remove the node from the exterior node list.
The exterior node list is GLOBALNODESLIST, and it is a Global variable.
Nothing is returned.

```{r new adj node removed from exterior/GLOBAL list}
exterior.node.removal<-function(removed.node){
  #By leaving the Global list in place, except for the node #, we may minimize lookup time
      GLOBALNODESLIST[[removed.node]][[1]]<- NA #Remove node from 
}
```
## Function to add node to District list
This function shall take in the node to be added.  It shall add the node to the district list.
The district.temp list is a global variable'.
```{r add new node to district}
node.to.add<-function(add.this.node){
  #district.temp
  #Build the list of lists to add to district list
  for (i in (length(adj.list)):1){
    if((as.numeric(adj.list[[i]][[1]]))==as.numeric(add.this.node)){
      #building individual node list to bring into district list
      
      
      temp1<-list()
      temp1[[length(temp1)+1]]<-(as.numeric(adj.list[[i]][[1]]))
      
      temp1[[length(temp1)+1]]<-(as.numeric(adj.list[[i]][[2]]))
      temp1[[length(temp1)+1]]<-adj.list[[i]][[3]]
      
      temp1[[length(temp1)+1]]<-(as.numeric(adj.list[[i]][[4]]))
      #templist<-list(temp1,temp2,temp3,temp4)
      district.temp[[length(district.temp)+1]]<-temp1 #Add node to district
      temp.pop<=temp.pop+adj.list[[i]][[2]]#Add population, so district will stop growing 
      #When 
    }
  }
}
```

## Function to pick a new node
This function will pick a new node for the proposed district by looking at the adjacency list and picking the node with the most adjacencies to the proposed district. In the case of a tie, it will use the queue structure inherit in the adjacency list.

```{r pick node}
pick.new.node<- function(temp.pop){
  node.number=-99
  #Prioritize nodes with max adjacency with the temp district
  temp.max<-0
  for (i in 1:length(adj.list)){
    if (adj.list[[i]][[4]]>=temp.max){
      if((temp.pop+as.integer(adj.list[[i]][[2]]))>Population_Range[2]){break}
      temp.max<-adj.list[[i]][[4]]
      node.number<-adj.list[[i]][[1]]
    }
  }
  
  return (node.number)
}

```

## Function to update the Adjacency List when node add to district
This function is given a list of the nodes that were adjacent to the node just added to the district.  It will check if these nodes are within the adj.list, and if not, will add them.  

```{r adj list update}
adj.list.update<-function(list.new.adj.nodes){
  for (k in 1:(length(list.new.adj.nodes))){ #loop through nodes to check
    It.is.here<-0
    
    for (i in 1: length(adj.list)){#for each node, check adj.list
      if(as.numeric(list.new.adj.nodes[k])==(as.numeric(adj.list[[i]][[1]]))){
        It.is.here=1
        #Update count
        adj.list[[i]][[4]]<-as.numeric(adj.list[[i]][[1]])+1
      }
     
    }
    #Node can neither be present or na to be added.
    if (It.is.here==0 && GLOBALNODESLIST[[list.new.adj.nodes[k]]]!=na){ #add the new node in the adjacency list
      add.node(list.new.adj.nodes[k])
    }
  }
  
}
```

## Creating a single District

```{r make district}

make.district<-function(){
  temp.pop=0
  #Re-Create this district node list.  It is a global variable, for ease of use between functions,
  #but needs to be set to empty for each 'run'
  #Re-Create this district adjacency list.  It is a global variable, for ease of use between functions,
  #but needs to be set to empty for each 'run'
  
temp_list<-list()
temp_list[[length(temp_list)+1]]<-c(0)
temp_list[[length(temp_list)+1]]<-c(0)
temp_list[[length(temp_list)+1]]<-c(0)
temp_list[length(temp_list)+1]<-c(0)
district.temp<-list()
district.temp[[(length(district.temp)+1)]]<-temp_list
adj.list<-list()
adj.list[[(length(adj.list)+1)]]<-temp_list
  
#Add node to district
  
  #Pick start Node, use very first valid node
  First.node<-1
  for (k in length(GLOBALNODESLIST):1){
    if (!(is.na(GLOBALNODESLIST[[k]][[1]]))){
      First.node<-as.numeric(GLOBALNODESLIST[[k]][[1]])
      break}
  
  }
  
  #Move  First Node to this district Node List
    
      
  temp1<-list()
  temp1[[length(temp1)+1]]<-(as.numeric(GLOBALNODESLIST[[First.node]][[1]]))
      
  temp1[[length(temp1)+1]]<-(as.numeric(GLOBALNODESLIST[[First.node]][[2]]))
  temp1[[length(temp1)+1]]<-GLOBALNODESLIST[[First.node]][[3]]
      
  temp1[[length(temp1)+1]]<-(as.numeric(GLOBALNODESLIST[[First.node]][[4]]))
      
  district.temp[[1]]<-temp1 #Add node to district
  
  #Add nodes to Adjacency List 
  
  First.adj<-GLOBALNODESLIST[[First.node]][[3]]
        
  adj.list.update(First.adj)
  
  #Remove from exterior list
  exterior.node.removal(First.node)
  
  while (temp.pop<Population_Range[2]){
    Next.node<-pick.new.node(temp.pop)
    if(Next.node==-99){break}
    #Add node to district.temp, remove from adj.list
    node.to.add(Next.node)
    node.to.remove(Next.node)
    
  }
  
}
```


## "Global Created Information ("Main")
The created information here is the heart of the program.  It will create lists of nodes and drive functions that will create districts.

```{r Base Global Information}
#make some global variables
temp_list<-list()
temp_list[[length(temp_list)+1]]<-c(0)
temp_list[[length(temp_list)+1]]<-c(0)
temp_list[[length(temp_list)+1]]<-c(0)
temp_list[length(temp_list)+1]<-c(0)
district.temp<-list()
district.temp[[(length(district.temp)+1)]]<-temp_list
adj.list<-list()
temp.pop<-0
adj.list[[(length(adj.list)+1)]]<-temp_list
#for (j in 1:number_districts){
  make.district()
  final_district[j]<-district.temp
#}



```

```{r test}
p.number<-function(guess){
  print(class(guess))
}
#exterior.node.removal(1)
#p.number(3)
```